---
description: 13기 강미경
---

# \[Lecture 5\] Convolutional Neural Networks

## CS231n 5강 리뷰

  5강부터는 본격적으로 Convolution Neural Network\(CNN\)에 대해 배운다. CNN의 등장배경과 기본적인 구조에 대해 배우며, CNN의 레이어가 어떤 역할을 하는지 구체적으로 알아볼 것이다. 

![](.gitbook/assets/image%20%28115%29%20%282%29%20%282%29%20%282%29.png)

## Contents

![](.gitbook/assets/image%20%2830%29.png)

## 1. CNN 등장 배경

![](.gitbook/assets/image%20%2815%29.png)

  먼저 CNN의 형태와 구조가 어떻게 구성되었는지 알아보기 위해, 그 등장배경을 살펴보도록 하자. 1959년, 고양이 뇌에 전극을 꽂고 다양한 자극을 주는 실험이 진행되었다. 이로부터 얻은 결론은 다음과 같은 세 가지이며, 이러한 실험 결과들을 바탕으로 CNN이 고안되었다고 볼 수 있다.

1. **뉴런은 모서리 정보나 그 형태에 반응하여 물체를 인식한다.**
2. **피질 내부에는 지형적 매핑\(topographical mapping\)이 존재한다.**
3. **뉴런들이 계층 구조\(Hierarchical organization\)로 영상을 처리한다.**

  두 번째로 설명한 피질 내부의 지형적 매핑은 **Locality\(지역성\)**와 **Spatial\(공간성\)** 이라는 두 가지 키워드로 보태어 설명할 수 있다. 사람이 어떠한 영상을 처리할 때 피질 내의 세포들 이를 처리하되 , 인접한 세포들이 모여서 처리하며\(**Locality**\) 이 세포들이 각자의 역할을 맡아서 처리하는 과정에서 영상 공간적\(**Spatial**\)으로 처리된다. 이러한 처리 과정을 지형적 매핑이 존재한다고 표현한다.

 또, 뉴런들이 계층 구조로 영상을 처리하기 때문에 위의 자료의 왼쪽처럼 Cell마다 물체의 어떤 특징에 반응하는지가 다르다. **Simple** cells은 보다 영상의 저차원적 특징을, **Hyper**-**complex cells**은 보다 고차원적인 특징에 반응한다.  

## 2. CNN 특징 및 구

![](.gitbook/assets/image%20%28127%29%20%281%29%20%281%29.png)

     번에는 CNN 구조의 특징을 앞서 설명한 CNN의 등장배경과 연결지어 펴보도록 하자.

1. Fully-Connected Layer와 다르게 이미지 기존의 구조를 유지한 채 레이어를 통과한다는 점에서 이미지의 **Spatial**한 특징을 그대로 가진 채 학습할 수 있다.
2. 이미지 데이터의 특성에 맞는 2차원 내지는 3차원의 필터를 통한 합성곱 연산\(Convolution Operation\)을 통해 **지역성\(Locality\)**이 보장된다.
3. 현재 Layer의 출력이 다음 레이어의 Input으로 들어가는 구조로, Feature들이 간단한 수준에서 점점 더 고차원적인 수준으로 변화해가는 **계층 구조**를 가진다.

![](.gitbook/assets/image%20%2829%29%20%282%29%20%282%29%20%282%29%20%281%29.png)

    혹시 지역성에 대한 개념이 잘 와닿지 않는다면 위의 자료를 보는 것도 좋을 것 같다. 자료의 출처가 된 링크는 다음과 같다.  [\[Link\]](https://medium.com/@seoilgun/cnn%EC%9D%98-stationarity%EC%99%80-locality-610166700979)

![](.gitbook/assets/image%20%2824%29%20%282%29%20%282%29%20%282%29%20%281%29.png)

  CNN의 특징을 봤다면, 이제는 구조를 보자. 다음과 같이 세 개의 구조가 적절히 반복되는 형태가 기본적이다. 보통 **Convolution Layer와 비선형 함수\(주로 RELU\)가 반복**된다. 기타 논문들이나 다른 자료에서는 Convolution 연산과 이에 따른 Activation map이 비선형 함수를 지나는 것을 포함하여 Convolution Layer라고 표현하기도 한다. 간간히 등장하는 **Pooling Layer**는 이미지의 크기를 축소하는 역할을 하며, 이를 통해 뽑아낸 특징을 더욱 invariant 하게 만들어주는 효과를 얻을 수 있다. CNN 구조의 맨 끝단에서 등장하는 **Fully Connected Layer**는 최종 스코어를 추출하기 위한 것이며, 위의 예시에서는 multi-classification 문제이므로 Softmax를 활성함수로 사용했다.

## 3. Convolution Layer

  CNN의 등장배경과 그 특징과 전체적인 구조를 배웠다면, 이제는 그 각각의 레이어가 어떤 역할을 하는지 살펴볼 것이다. 첫 번째로는 CNN의 핵심이라고 볼 수 있는 **Convolution Layer**를 살펴보자.

![](.gitbook/assets/image%20%28108%29.png)

  Fully Connected Layer에서 이미지를 처리하려면 데이터를 1차원 벡터로 쭉 stretch 하여 네트워크의 Input으로 넣어야 한다. 그리고 우리가 익히 들어 알고있는 것과 같이, 가중치 벡터와 입력벡터가 내적하면서 연산이 이루어진다.

![](.gitbook/assets/image%20%289%29%20%282%29%20%282%29%20%282%29.png)

  반면 Convolution Layer의 연산은 좀 다른 형태로 이루어진다. 먼저 입력 데이터가 1차원이 아니라, 이미지 데이터의 생김새 그대로이다. **데이터의 공간적 특성을 그대로 유지한 채 레이어를 통과하는 것이다.** 그리고 필터를 바탕으로 한 연산이 이루어진다. 필터가 이미지를 슬라이딩 하면서 공간적인 내적을 수행한다.

![](.gitbook/assets/image%20%2844%29.png)

  이 필터의 차원과 개수는 혼동되기 쉬운 개념이기 때문에 잘 잡고가는 것이 중요하다. **필터의 차원은 Input feature map의 차원과 같다.** 즉, 32x32x3 사이즈의 Input feature map을 Convolution 연산하기 위해서는 채널이 3인 필터가 필요하다는 것이다. 필터는 이미지의 부분부분을 슬라이딩해 나가지만 그 depth는 모두 훑고 지나가기 때문이다.

![](.gitbook/assets/image%20%28119%29%20%285%29%20%281%29.png)

   다음은 필터의 개수이다. **필터의 차원과 달리 필터의 개수는 Output feature map의 차원\(채널\)과 같다.**  위의 예제에서 출력으로 채널이 3인 Activation map\(Output feature map\)을 얻고 싶다면 필터 5x5x3짜리 필터 3개가 필요하다.

 각 필터는 서로 다른 특징을 추출하기 때문에 위의 그림에서 파랑 필터와 초록 필터는 서로 다른 특징을 가지고 있다. 때문에  Activation map의 각 채널 또한 서로 다른 특징을 가지고 있다. 그리고 특징은 풍부하게 뽑는 것이 좋기 때문에 보통은 여러 개의 필터를 사용하며, 그 개는 강의에서 언급되었던 것과 같이 보통 2의 제곱수 인 32, 64, 128, 512 등으로 사용한다고 한다.

![](.gitbook/assets/image%20%28109%29%20%284%29%20%281%29%20%2817%29.png)

 이 그림은 필터가 어떻게 생겼는지 이해하기 좋은 자료이다. 각 그리드의 요소들은 **필터를 시각화**한 것이다. Input으로 들어가는 강아지 사진에 대해서, Convolution Layer들 내부의 각 필터들이 어떻게 생겼는지 볼 수 있다. 각 필터의 모습들은 Convolution 연산에서 필터가 이미지를 슬라이드해 나갈 때, 이미지의 어떤 특징을 잡아낼 것인지를 표현한다. 

 가령, 노랑색 필터는 이미지에서 '노랑색'을 잡아내는 필터라고 할 수 있다. 그러면 이미지를 이 노랑색 필터가 슬라이드해 나가면서 합성곱 연산을 한다고 할 때, 이 필터는 이미지에서 다른 곳들보다도 노란색을 많이 품고 있는 강아지의 몸통 부분에서 반응할 것이고, 그 결과로 나오는 Activation map은 해당 부분에서 높은 값을 가진 형태일 것이다.

  또 한가지 눈여겨볼 점은, 처음 low level의 필터은 edge 정보, 간단한 색상 등의 낮은 차원의 특징들을 가지고 있는 반면, high-level의 특징\(오른쪽들\)로 갈수록 필터들이 고차원적인 특징을 담고 있다는 것이다.  보다 깊은 층의 레이어에서 추출한 Conv5\_3레이어의 필터는 체적인 모습을 특징으로 담고 있는 것을 볼 수 있다. 

![](.gitbook/assets/image%20%2879%29%20%283%29%20%283%29%20%283%29.png)

  다음으로 살펴볼 것 Activation map을 시각화한 것이다.  맨 상단, 1차원 벡터의 형태로 나와있는 것은 필터이다. 그리고 그 아래 회색으로 표현된 그리드의 각 요소들은 이들 필터로 연산한 결과들을 나타낸다. 

 예를 들어, 빨간색 박스로 표시되어 있는 필터는 대각선 edge를 표현하는 필터라고 볼 수 있다. 그리고 이 필터를 통한 연산결과를 보니, Input Image로 들어간 자동차 헤드라이트 이미지에서 해당 edge가 나타난 부분에서 흰색 값으로 마치 테두리처럼 나타난 것을 볼 수 있다. 값이 크다는 것은 연산 결과가 크다는 것을 의미하며, 이미지 데이터의 픽셀은 그 값이 클수록 밝게 나타난다는 점을 참고하면 이해하기 쉬울 것이다. 

![](.gitbook/assets/image%20%2862%29.png)

  이쯤에서 다음으로 넘어가기 전에 간단히 정리해보자. 

  **각 필터는 모두 자기만의 표현특징들을 가지고 있으며 합성곱 연산이 이루어지면 그 결과인 Activation map은 해당 필터가 표현하는 특징을 가진 부분에서 높은 값이 나타난다.**

![](.gitbook/assets/image%20%2851%29.png)

 이제는 Convolution 연산 시에 옵션처럼 추가할 수 있는 스트라이드와 패딩을 알아볼 것이. 먼저 스트라이드는 필터가 이미지를 슬라이딩 할 때, 어떤 간격으로 슬라이딩 해나갈지 결정하는 요소이다. 스트라이드와 필터의 크기가 주어졌을 때, 결과인 Activation Map이 어떤 크기일지 계산하는 공식도 강의에서 나왔다. 

  32x32 Input Feature Map을 5x5 필터로, stride를 1로 주어 연산했을 때의 Output Feature Map의 크기는 다음과 같이 계산할 수 있다. \[\(32-5\)/1\] + 1 = 28

![](.gitbook/assets/image%20%2837%29.png)

  다음은 패딩이다. 패딩의 역할은 크게 두 가지로 정리해볼 수 있다. **출력 이미지의 크기를 맞춰주는 것**과 **가장 자리의 정보를 보존해주는 것**이다. 

  Convolution 연산이 이루어지면 그 출력 피쳐맵의 크기는 작아질 수 밖에 없다. 방금의 예시에서도 32x32의 Input은 5x5필터를 만나 28x28로 줄어들었다. 그렇다면 레이어가 반복되면서 점점 이미지의 크기는 줄어들 것이며 이는 정보의 손실로 이어진다. 때문에 패딩을 통해 Input과 Output의 크기를 맞춰주는 것이다.

 또 모서리의 경우 필터 연산이 이루어질 때, 그 부분은 언제나 필터의 중앙에 위치할 수 없다. 또 다른 부분보다 필터도 한 번밖에 슬라이드되지 않는다. 패딩을 해주면 이 모서리 부분도 공평하게 피쳐 추출에 반영할 수 있다는 장점이 있다. 패딩은 보통 zero-padding을 사용한다. 모서리 부분을 0으로 채우는 것이다. 다른 패딩의 방법도 있다고 하지만 보통 무난하게 zero-padding이 잘 작동한다고 한다.

![](.gitbook/assets/image%20%28110%29.png)

  Convolution Layer에서의 연산과 이에 사용되는 몇 가지 개념들을 배워보았다. 다음으로 넘어가기 전,  자 주 등장할 개념인 Receptive Field에 대해 짚고 넘어가보도록 하자. 이 Receptive Field란 한글로 하면 '수용 영역' 혹은 '수용장' 정도로 해석할 수 있다. 이는 하나의 필터가 한 번에 수용할 수 있는 영역을 말한다. 쉽게 말해 만약 5x5 필터를 가지고 Convolution 연산을 진행하면, 이 필터는 이미지의 각 부분을 슬라이드 해나갈 때 한 번에 5x5 영역을 보기 때문에 이 때의 수용영역은 5x5가 된다.

## 4. Pooling Layer + Fully Connected Layer 

![](.gitbook/assets/image%20%2868%29.png)

  이제는 Pooling Layer에 대해 알아보자. \(슬라이드에서 제목이 Stride/Padding으로 잘못나왔으나 Pooling에 대한 설명이 맞다.\) Pooling Layer에서는 이미지의 크기를 줄인다. 이때 차원은 변하지 않는다는 것이 특징이며, 이는 Feature map의 크기를 줄임으로써 정보를 압축하는 효과와 추출한 피쳐에 불변성\(invariant\)을 부여하는 효과를 준다. 가장 많이 쓰이는 것은 max-pooling이며, 이는 필터가 슬라이드 하는 부분들에서 각각 가장 큰 값을 선택하는 방식이다. 또 stride는 필터 크기 만큼 줌으로써 서로 겹치지 않게 풀링하는 것이 일반적이다.

![](.gitbook/assets/image%20%2875%29.png)

  Stride와 Pooling에 대한 비교가 잠시 언급되었었다.  Convolution 연산 시 Stride를 2이상으로 주어 Output Feature map의 크기를 Input보다 작게 만드는 방법과 별도의 Pooling Layer를 통해 피쳐맵의 크기를 줄이는 것의 차이인데, 일단 둘 다 Down Sampling 한다는 공통점이 존재한다. 다만 우리가 아는대로, 그 효과와 연산과정은 엄연히 다를 것이다.

 기존은 Convolution Layer 세 개에 Pooling Layer 하나가 반복되는 등의 구조로 중간중간 풀링을 통해 별도로 피쳐맵의 크기를 줄이는 방법을 많이 사용했으나, 최근은 stride를 바탕으로 down sampling 하는 것이 성능이 더 좋게 나오고 있다고 한다. 실제로 ResNet에서도 복잡도를 줄이기 위해 max-pooling 하지 않고, 출력 피쳐맵 크기를 줄이려고 하는 경우,  해당 Convolution Layer에서 stride를 2로 주는 방식을 선택했다고 한다.

![](.gitbook/assets/image%20%2846%29.png)

  다음은 마지막인 Fully Connected Layer이다. 전결합계층이라고도 한다. 이는 앞서 한번 언급했던 것 이외에 큰 특징은 없고, 다시 정리하자면 출력 피쳐맵을 flatten하여 1차원 벡터로 만든 후 레이어의 입력으로 사용하며, 이 예제에서는 multi-class 분류 문제를 해결하기 위해 softmax 함수를 바탕으로 최종 스코어를 출력한 것을 볼 수 있었다.

![](.gitbook/assets/image%20%2836%29.png)

 지금까 CNN의 레이어들에 대해서 살펴보았다. 마지막으로는 위의 자료를 바탕으로 몇 가지 시사할 점을 짚고 넘어가보려고 한다. 이 그리드의 각각의 요소들은 Activation map, 즉 필터 연산의 결과물이다. 

    **1. Feature의 형태 변화**

    초기의 결과물들은 차의 가장자리, 즉 edge 정보 위주로 추출된 것을 볼 수 있다. 하지만 뒤로 갈수록 점점 Activation map에는 차의 전반적인 형태와 같은 전체적인, 혹은 고차원적인 특징이 추출된 것을 볼 수 있다. 

   **2. RELU 함수를 지난** 

   Convolution 다음에는 항상 RELU가 따라온다. 그리고 RELU는 음수인것들은 모두 0으로 보내버리고, 양수인애들 그대로 흘려보내는 형태이다. 우리의 Activation map에서의 양수란, 필터가 표현하는 특징이 나타난 부분들일 것이고, 음수라면 나타나지 않은 부분일 것이다. 그리고 값이 클수록 필터가 표현하는 특징이 강하게 나타난 부분이라고 볼 수 있다. 그러면 RELU 함수를 만난 Activation map은 다음과 같이, 필터가 표현하는 특징이 있는 곳에는 그대로 밝은 값을, 그렇지 않은 부분들의 픽셀값은 모두 0으로 바뀌어 까맣게 표현된다고 볼 수 있다.

  **3. Pooling layer를 지난 후**

  풀링 레이어는 다른 걸 하지는 않고 이미지의 해상도, 즉 사이즈를 줄인다. 사이즈를 줄이면, 화질은 줄어듭니다. 허나 그냥 사이즈만 줄였기 때문에 그 추출된 특징의 형태는 변함이 없는 것을 알 수 있다.

이미 앞에서 정리한 내용들이지만, 실제 Activation map을 보면서 한번 더 상기시키면 더욱 더 기억에 잘 남지 않을까하여 짚어보았다.

![](.gitbook/assets/image%20%2842%29.png)

  강의 리뷰는 이렇게 마무리할 수 있을 것 같다. 이번 강의에서는 다음과 같은 키워드 위주로 학습하였으므로, 한번씩 이 개념들에 대해 상기시켜보는 것도 좋은 복습 방법일 듯 하다. 

  이상으로 CS231n Lecture5 Convolution Neural Network 리뷰를 여기서 마친다.

